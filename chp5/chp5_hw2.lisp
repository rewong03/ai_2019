; Write a predicate BOILINGP that takes two inputs, TEMP and SCALE, and returns T if the temperature is above the boiling point of water on the specified scale. If the scale is FAHRENHEIT, the boiling point is 212 degrees; if CELSIUS, the boiling point is 100 degrees. Also write versions using IF and AND/OR instead of COND.

(defun boilingp (temp scale)
  (or (and (equal scale 'farenheit)
           (> temp 212))
      (and (equal scale 'celsius)
           (> temp 100))))

; Write a program to return the distribution of results generated by N=100 calls to the function below. The distribution should be an association list of the form '((heads 48) (tails 49) (edge 3)). After you do that, explain if you believe the coin function works as intended.

(defun coin ()
  (cond ((< (random 101) 50) 'heads)
        ((> (random 101) 50) 'tails)
        (t 'edge)))

(defun coin-dist ()
  (loop for i from 1 to 100
        for toss = (coin)
        collect toss into tosses
        finally (return (list (count 'heads tosses)
                              (count 'tails tosses)
                              (count 'edge tosses)))))

; Coin doesn't work as expected because it calls random twice instead of just once.

; Write (beforep x y input) which returns true if x appears before y in the input list.

(defun beforep (x y input)
  (< (position x input)
     (position y input)))

; Write a function ADD-VOWELS that takes a set of letters as input and adds the vowels (A E I O U) to the set. For example, calling ADD- VOWELS on the set (X A E Z) should produce the set (X A E Z I O U), except that the exact order of the elements in the result is unimportant.

(defun add-vowels (str)
  (loop with vowels = '(a e i o u)
        for letter in str
        if (member letter vowels)
        do (setf vowels (remove letter vowels))
        finally (return (append str vowels))))

; Write a function upside-down that takes in a list such as '(up down up up) and flips each element, returning '(down up down down). The only elements in the list will be up and down. Method to use: write an anonymous flipper function and use mapcar.

(defun upside-down (directions)
  (mapcar (lambda (dir)
            (if (equal dir 'up)
                'down
                'up))
          directions))

; Write a function that takes two inputs, xs and k, and returns the first number in the list xs that is roughly equal to k. Let’s say that “roughly equal” means no less than k − 10 and no more than k + 10. Use loop.

(defun close-enough (xs k)
  (loop for x in xs
        if (<= (abs (- k x)) 10)
        return x))

(defun close-enough (xs k)
  (find-if (lambda (x)
             (<= (abs (- k x)) 10))
           xs))

; 7.10
(defparameter *notes*
  '((c 1)
    (c-sharp 2)
    (d 3)
    (d-sharp 4)
    (e 5)
    (f 6)
    (f-sharp 7)
    (g 8)
    (g-sharp 9)
    (a 10)
    (a-sharp 11)
    (b 12)))

(defvar note-table *notes*)

(defun numbers (notes)
  (loop for note in notes
        collect (first (cdr (assoc note note-table)))))

(defun note-searcher (number)
  (loop for note in note-table
        if (equal (cdr note)
                  (list number))
        return (car note)))

(defun notes (numbers)
  (loop for number in numbers
        collect (note-searcher number)))

(defun raise (steps numbers)
  (loop for number in numbers
        collect (+ number steps)))

(defun normalize (numbers)
  (loop for number in numbers
        if (> number 12)
        collect (- number 12)
        if (< number 0)
        collect (+ number 12)
        collect number))

(defun transpose (steps notes)
  (notes (normalize (raise steps (numbers notes)))))


